# -*- coding: utf-8 -*-
"""RESUME - Solar Panel Regression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hdhJdzcF8OH0hQsjIYdkiF7AUfBvgyI-
"""

# -*- coding: utf-8 -*-
"""For Deployment Solar_Panel_Regression_Group_4.ipynb"""

import numpy as np
import pandas as pd
import pickle
from sklearn.ensemble import GradientBoostingRegressor
import streamlit as st

# =========================================================
#  LOAD CSV AND TRAIN MODEL
# =========================================================

df = pd.read_csv('solarpowergeneration.csv')

# Fill missing values
df['average-wind-speed-(period)'] = df['average-wind-speed-(period)'].fillna(
    df['average-wind-speed-(period)'].mean()
)

# Separate features & target
df_features = df.drop(['power-generated'], axis=1)
y = df['power-generated']

# ---------- Compute REAL scaling (means & stds) ----------
training_means = {}
training_stds = {}

scaled_df = df_features.copy()
for col in scaled_df.select_dtypes(include=[np.number]).columns:
    mean_val = scaled_df[col].mean()
    std_val = scaled_df[col].std()

    training_means[col] = mean_val
    training_stds[col] = std_val

    if std_val != 0:
        scaled_df[col] = (scaled_df[col] - mean_val) / std_val
    else:
        scaled_df[col] = 0.0

# Split
# ---------- Manual Split (80% train, 20% test) ----------
# Set random seed for reproducibility
np.random.seed(42)

# Total number of samples
n_samples = len(scaled_df)

# Shuffle indices manually
shuffled_indices = np.random.permutation(n_samples)

# Compute train size (80%)
train_size = int(0.8 * n_samples)

# Train and test indices
train_indices = shuffled_indices[:train_size]
test_indices = shuffled_indices[train_size:]

# Split X
x_train = scaled_df.iloc[train_indices]
x_test = scaled_df.iloc[test_indices]

# Split y
y_series = df["power-generated"]
y_train = y_series.iloc[train_indices]
y_test = y_series.iloc[test_indices]


# Train Model
model = GradientBoostingRegressor(
    learning_rate=0.1,
    max_depth=3,
    n_estimators=100,
    random_state=42
)
model.fit(x_train, y_train)

# Save model
with open('gradient_boosting_model.pkl', 'wb') as f:
    pickle.dump(model, f)

# Save scaling values
with open("scaling_values.pkl", "wb") as f:
    pickle.dump((training_means, training_stds), f)


# =========================================================
# STREAMLIT
# =========================================================

st.set_page_config(
    page_title="Solar Panel Regression App",
    page_icon="‚ö°",
    layout="wide"
)

# ----------------- Custom UI CSS -----------------
st.markdown("""
    <style>
        .main { background-color: #f4f7fa; }
        .title-text { font-size: 40px; font-weight: 800; color: #1B7F79; text-align: center; padding-bottom: 10px; }
        .sub-text { text-align: center; font-size: 20px; color: #333; margin-top: -15px; padding-bottom: 20px; }
        .input-card { background: white; padding: 25px; border-radius: 15px; box-shadow: 0px 4px 12px rgba(0,0,0,0.1); }
        .prediction-box { background: #1B7F79; color: white; padding: 18px; border-radius: 12px;
                          text-align: center; font-size: 24px; font-weight: 700; margin-top: 20px; }
    </style>
""", unsafe_allow_html=True)

# Header
st.markdown("<h1 class='title-text'>‚ö° Solar Panel Regression App</h1>", unsafe_allow_html=True)
st.markdown("<p class='sub-text'>Gradient Boosting based Power Generation Prediction</p>", unsafe_allow_html=True)


# =========================================================
#  LOAD MODEL + REAL MEANS & STDS
# =========================================================

@st.cache_resource
def load_artifacts():
    with open("gradient_boosting_model.pkl", "rb") as f:
        model = pickle.load(f)

    with open("scaling_values.pkl", "rb") as f:
        means, stds = pickle.load(f)

    return model, means, stds

model, means, stds = load_artifacts()


# =========================================================
#  INPUT UI
# =========================================================

st.markdown("<div class='input-card'>", unsafe_allow_html=True)
st.markdown("### üå§ Enter Environmental Parameters")
st.markdown("Provide values for the solar panel environment to predict power output.")

cols = st.columns(3)
user_input = {}
feature_list = list(means.keys())

for i, feature in enumerate(feature_list):
    with cols[i % 3]:

        # Special formatting for distance-to-solar-noon
        if feature == "distance-to-solar-noon":
            user_input[feature] = st.number_input(
                feature.replace("-", " ").title(),
                value=float(means[feature]),
                format="%.15f"   # <<< 15 decimal places
            )

        else:
            user_input[feature] = st.number_input(
                feature.replace("-", " ").title(),
                value=float(means[feature])
            )


st.markdown("</div>", unsafe_allow_html=True)

user_df = pd.DataFrame([user_input])


# =========================================================
# SCALING FUNCTION (REAL VALUES)
# =========================================================

def standard_scale(df):
    scaled = df.copy()
    for col in df.columns:
        mean_val = means[col]
        std_val = stds[col]

        if std_val == 0:
            scaled[col] = 0.0
        else:
            scaled[col] = (scaled[col] - mean_val) / std_val

    return scaled

scaled_user_df = standard_scale(user_df)


# =========================================================
# PREDICTION
# =========================================================

if st.button("üîç Predict Power Generation", use_container_width=True):

    # Raw (non-scaled) values
    raw_values = user_df.to_numpy().flatten()

    # Rule: All inputs = zero ‚Üí output = zero
    if np.allclose(raw_values, 0.0):
        st.info("All inputs are zero ‚Äî predicted power = 0 kW")
        st.markdown("<div class='prediction-box'>üåû Predicted Power: <br>0.00 kW</div>", unsafe_allow_html=True)

    else:
        prediction = model.predict(scaled_user_df)[0]
        st.markdown(
            f"<div class='prediction-box'>üåû Predicted Power: <br>{prediction:.2f} kW</div>",
            unsafe_allow_html=True
        )